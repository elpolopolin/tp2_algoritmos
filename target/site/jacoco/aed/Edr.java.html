<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Edr.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">labo4</a> &gt; <a href="index.source.html" class="el_package">aed</a> &gt; <span class="el_source">Edr.java</span></div><h1>Edr.java</h1><pre class="source lang-java linenums">package aed;
// E: cantidad total de estudiantes
// R: cantidad total de respuestas del examen
// k: parámetro para consultarDarkWeb
// S: cantidad de sospechosos
// V: cantidad de notas válidas
public class Edr {
    private class Estudiante implements Comparable&lt;Estudiante&gt; {
        int id; // O(1)
        int[] respuestas; // O(1)
        int puntaje; // O(1)
        boolean entregado; // O(1)
        int respuestasCorrectas; // O(1)
        boolean esCopion; // O(1)
        Handle&lt;Estudiante&gt; heap_handle; // O(1)

<span class="fc" id="L17">        Estudiante(int id, int R) { // O(R)</span>
<span class="fc" id="L18">            this.id = id; // O(1)</span>
<span class="fc" id="L19">            this.respuestas = new int[R]; // O(R)</span>
<span class="fc bfc" id="L20" title="All 2 branches covered.">            for (int i = 0; i &lt; R; i++) { // Bucle O(R)</span>
<span class="fc" id="L21">                this.respuestas[i] = -1; // O(1)</span>
            }
<span class="fc" id="L23">            this.puntaje = 0; // O(1)</span>
<span class="fc" id="L24">            this.entregado = false; // O(1)</span>
<span class="fc" id="L25">            this.respuestasCorrectas = 0; // O(1)</span>
<span class="fc" id="L26">            this.esCopion = false; // O(1)</span>
<span class="fc" id="L27">            this.heap_handle = null; // O(1)</span>
<span class="fc" id="L28">        }</span>

        @Override
        public int compareTo(Estudiante otro) { // O(1)
<span class="fc bfc" id="L32" title="All 2 branches covered.">            if (this.puntaje != otro.puntaje) { // O(1)</span>
<span class="fc" id="L33">                return Integer.compare(this.puntaje, otro.puntaje); // O(1)</span>
            }
<span class="fc" id="L35">            return Integer.compare(this.id, otro.id); // O(1)</span>
        }
    }

    private Estudiante[] estudiantes; // O(1)
    private Heap&lt;Estudiante&gt; puntajesDeEstudiantes; // O(1)
    private int[] ExamenCanonico; // O(1)
    private int LadoAula; // O(1)
<span class="fc" id="L43">    private boolean[] _esCopion = null; // O(1)</span>

    // Complejidad: O(E*R)
<span class="fc" id="L46">    public Edr(int LadoAula, int Cant_estudiantes, int[] ExamenCanonico) { // O(E*R)</span>
<span class="fc" id="L47">        this.LadoAula = LadoAula; // O(1)</span>
<span class="fc" id="L48">        this.ExamenCanonico = new int[ExamenCanonico.length]; // O(R)</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">        for (int i = 0; i &lt; ExamenCanonico.length; i++) { // Bucle O(R)</span>
<span class="fc" id="L50">            this.ExamenCanonico[i] = ExamenCanonico[i]; // O(1)</span>
        }
<span class="fc" id="L52">        this.estudiantes = new Estudiante[Cant_estudiantes]; // O(E)</span>
<span class="fc" id="L53">        this.puntajesDeEstudiantes = new Heap&lt;&gt;(); // O(1)</span>
<span class="fc" id="L54">        int R = this.ExamenCanonico.length; // O(1)</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (int i = 0; i &lt; Cant_estudiantes; i++) { // Bucle O(E)</span>
<span class="fc" id="L56">            Estudiante est = new Estudiante(i, R); // O(R)</span>
<span class="fc" id="L57">            est.heap_handle = puntajesDeEstudiantes.insertar(est); // O(log E)</span>
<span class="fc" id="L58">            estudiantes[i] = est; // O(1)</span>
        }
<span class="fc" id="L60">    }</span>

    // Complejidad: O(E)
    public double[] notas() { // O(E)
<span class="fc" id="L64">        double[] res = new double[estudiantes.length]; // O(E)</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="fc" id="L66">            res[i] = estudiantes[i].puntaje; // O(1)</span>
        }
<span class="fc" id="L68">        return res; // O(1)</span>
    }

    // Complejidad: O(log E)
    public void resolver(int estudiante, int NroEjercicio, int res) { // O(log E)
<span class="fc" id="L73">        Estudiante est = estudiantes[estudiante]; // O(1)</span>
<span class="fc" id="L74">        int respuesta_previa = est.respuestas[NroEjercicio]; // O(1)</span>
<span class="fc" id="L75">        est.respuestas[NroEjercicio] = res;</span>

<span class="fc bfc" id="L77" title="All 4 branches covered.">        boolean eraCorrecta = (respuesta_previa != -1 &amp;&amp; respuesta_previa == ExamenCanonico[NroEjercicio]); // O(1)</span>
<span class="pc bpc" id="L78" title="1 of 4 branches missed.">        boolean esCorrecta = (res != -1 &amp;&amp; res == ExamenCanonico[NroEjercicio]); // O(1)</span>

<span class="pc bpc" id="L80" title="1 of 4 branches missed.">        if (eraCorrecta &amp;&amp; !esCorrecta) { // O(1)</span>
<span class="fc" id="L81">            est.respuestasCorrectas--; // O(1)</span>
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">        } else if (!eraCorrecta &amp;&amp; esCorrecta) { // O(1)</span>
<span class="fc" id="L83">            est.respuestasCorrectas++; // O(1)</span>
        }

<span class="fc" id="L86">        int nuevo_puntaje = (est.respuestasCorrectas * 100) / ExamenCanonico.length; // O(1)</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (nuevo_puntaje != est.puntaje) { // O(1)</span>
<span class="fc" id="L89">            est.puntaje = nuevo_puntaje; // O(1)</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">            if (est.heap_handle != null) { // O(1)</span>
<span class="fc" id="L91">                puntajesDeEstudiantes.actualizarPrioridad(est.heap_handle); // O(log E)</span>
            }
        }
<span class="fc" id="L94">    }</span>

    // Complejidad: O(R + log E)
    public void copiarse(int estudiante_id) {
<span class="fc" id="L98">        Estudiante est = estudiantes[estudiante_id]; // O(1)</span>
<span class="fc" id="L99">        int[] vecinos_ids = new int[3]; // O(1)</span>
<span class="fc" id="L100">        int num_vecinos = 0; // O(1)</span>

        // calcular C = estudiantes por fila (si LadoAula par -&gt; LadoAula/2, si impar -&gt; (LadoAula+1)/2)
        int C;
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (LadoAula % 2 == 0) {</span>
<span class="fc" id="L105">                C = LadoAula / 2; // O(1)</span>
        } else {
<span class="fc" id="L107">            C = (LadoAula + 1) / 2; // O(1)</span>
        }

        // Izquierda: id-1 (existe si posición en fila &gt; 0)
<span class="fc bfc" id="L111" title="All 4 branches covered.">            if (estudiante_id &gt; 0 &amp;&amp; (estudiante_id / C) == ((estudiante_id - 1) / C)) {</span>
<span class="fc" id="L112">                vecinos_ids[num_vecinos++] = estudiante_id - 1;</span>
            }
        // Derecha: id+1 (existe si posición en fila &lt; C-1 y dentro de total estudiantes)
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">            if ((estudiante_id + 1) &lt; estudiantes.length &amp;&amp; (estudiante_id / C) == ((estudiante_id + 1) / C)) {</span>
<span class="fc" id="L116">                vecinos_ids[num_vecinos++] = estudiante_id + 1;</span>
            }
        // Adelante (arriba): id - C (existe si estamos en fila &gt; 0, es decir id &gt;= C)
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (estudiante_id &gt;= C) {</span>
<span class="fc" id="L120">            int adelante = estudiante_id - C;</span>
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">            if (adelante &gt;= 0 &amp;&amp; adelante &lt; estudiantes.length) {</span>
<span class="fc" id="L122">                vecinos_ids[num_vecinos++] = adelante;</span>
            }
        }

<span class="fc" id="L126">        int mejor_vecino_id = -1; // O(1)</span>
<span class="fc" id="L127">        int max_respuestas_nuevas = -1; // O(1)</span>

        // 2. Encontrar el mejor vecino (3 iteraciones max)
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (int i = 0; i &lt; num_vecinos; i++) {</span>
<span class="fc" id="L131">            int vecino_id = vecinos_ids[i]; // O(1)</span>
<span class="fc" id="L132">            Estudiante potencial_vecino = estudiantes[vecino_id]; // O(1)</span>
            
<span class="fc" id="L134">            int respuestas_nuevas = 0; // O(1)</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            for (int j = 0; j &lt; ExamenCanonico.length; j++) { // Bucle O(R)</span>
<span class="fc bfc" id="L136" title="All 4 branches covered.">                if (potencial_vecino.respuestas[j] != -1 &amp;&amp; est.respuestas[j] == -1) { // O(1)</span>
<span class="fc" id="L137">                    respuestas_nuevas++; // O(1)</span>
                }
            }

<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (respuestas_nuevas &gt; max_respuestas_nuevas) { // O(1)</span>
<span class="fc" id="L142">                max_respuestas_nuevas = respuestas_nuevas; // O(1)</span>
<span class="fc" id="L143">                mejor_vecino_id = vecino_id; // O(1)</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            } else if (respuestas_nuevas == max_respuestas_nuevas) { // O(1)</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (vecino_id &gt; mejor_vecino_id) { // O(1)</span>
<span class="fc" id="L146">                    mejor_vecino_id = vecino_id; // O(1)</span>
                }
            }
        }
<span class="fc bfc" id="L150" title="All 4 branches covered.">        if (mejor_vecino_id == -1 || max_respuestas_nuevas == 0) {</span>
<span class="fc" id="L151">            return;</span>
        }

        // Copiar la primera respuesta y recalcular puntaje
<span class="fc" id="L155">        Estudiante vecino = estudiantes[mejor_vecino_id]; // O(1)</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        for (int j = 0; j &lt; ExamenCanonico.length; j++) { // Bucle O(R)</span>
<span class="fc bfc" id="L157" title="All 4 branches covered.">            if (vecino.respuestas[j] != -1 &amp;&amp; est.respuestas[j] == -1) { // O(1)      </span>
<span class="fc" id="L158">                int respuesta_a_copiar = vecino.respuestas[j]; // O(1)</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                boolean esCorrecta = (respuesta_a_copiar == ExamenCanonico[j]); // O(1)</span>

<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                if (esCorrecta) { // O(1)</span>
<span class="fc" id="L162">                    est.respuestasCorrectas++; // O(1)</span>
                }

<span class="fc" id="L165">                est.respuestas[j] = respuesta_a_copiar; // O(1)</span>
<span class="fc" id="L166">                int nuevo_puntaje = (est.respuestasCorrectas * 100) / ExamenCanonico.length; // O(1)</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                if (nuevo_puntaje != est.puntaje) { // O(1)</span>
<span class="fc" id="L169">                    est.puntaje = nuevo_puntaje; // O(1)</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                    if (est.heap_handle != null) { // O(1)</span>
<span class="fc" id="L171">                        puntajesDeEstudiantes.actualizarPrioridad(est.heap_handle); // O(log E)</span>
                    }
                }

<span class="fc" id="L175">                return; // O(1)</span>
            }
        }
<span class="nc" id="L178">    }</span>

    // Complejidad: O(log E)
    public void entregar(int estudiante) { // O(log E)
<span class="fc" id="L182">        Estudiante est = estudiantes[estudiante]; // O(1)</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (!est.entregado) { // O(1)</span>
<span class="fc" id="L184">            est.entregado = true; // O(1)</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (est.heap_handle != null) { // O(1)</span>
<span class="fc" id="L186">                est.heap_handle.eliminar(); // O(log E)</span>
<span class="fc" id="L187">                est.heap_handle = null; // O(1)</span>
            }
        }
<span class="fc" id="L190">    }</span>

    // Complejidad: O(k * (R + log E))
    public void consultarDarkWeb(int k, int[] examenDW) { // O(k * (R + log E))
<span class="fc bfc" id="L194" title="All 2 branches covered.">        int count = (k &lt; puntajesDeEstudiantes.cardinal()) ? k : puntajesDeEstudiantes.cardinal(); // O(1)</span>
<span class="fc" id="L195">        Estudiante[] peores = new Estudiante[count]; // O(k)</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) { // Bucle O(k)</span>
<span class="fc" id="L197">            peores[i] = puntajesDeEstudiantes.extraerMinimo(); // O(log E)</span>
        }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) { // Bucle O(k)</span>
<span class="fc" id="L200">            Estudiante est = peores[i]; // O(1)</span>
<span class="fc" id="L201">            est.respuestas = examenDW.clone(); // O(R)</span>
<span class="fc" id="L202">            est.respuestasCorrectas = 0; // O(1)</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            for (int j = 0; j &lt; est.respuestas.length; j++) { // Bucle O(R)</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">                if (est.respuestas[j] != -1 &amp;&amp; est.respuestas[j] == ExamenCanonico[j]) { // O(1)</span>
<span class="fc" id="L205">                    est.respuestasCorrectas++; // O(1)</span>
                }
            }
<span class="fc" id="L208">            int nuevo_puntaje = (est.respuestasCorrectas * 100) / ExamenCanonico.length; // O(1)</span>
<span class="fc" id="L209">            est.puntaje = nuevo_puntaje; // O(1)</span>
<span class="fc" id="L210">            est.heap_handle = puntajesDeEstudiantes.insertar(est); // O(log E)</span>
        }
<span class="fc" id="L212">    }</span>

    // Complejidad: O(E*R) ya que el valor de las respuestas es acotado.
        public int[] chequearCopias() { // O(E*R)
<span class="fc" id="L216">                boolean alguienSeCopio = false; // O(1)</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">                if (estudiantes[i].esCopion) { // O(1)</span>
<span class="nc" id="L219">                    alguienSeCopio = true; // O(1)</span>
<span class="nc" id="L220">                    break; // O(1)</span>
                }
            }
    
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (alguienSeCopio) { // O(1)</span>
<span class="nc" id="L225">                int count = 0; // O(1)</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                    if (estudiantes[i].esCopion) { // O(1)</span>
<span class="nc" id="L228">                        count++; // O(1)</span>
                    }
                }
<span class="nc" id="L231">                int[] res = new int[count]; // O(S)</span>
<span class="nc" id="L232">                int index = 0; // O(1)</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                    if (estudiantes[i].esCopion) { // O(1)</span>
<span class="nc" id="L235">                        res[index++] = i; // O(1)</span>
                    }
                }
<span class="nc" id="L238">                this._esCopion = new boolean[estudiantes.length]; // O(E)</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                for(int i=0; i&lt;res.length; i++){ // Bucle O(S)</span>
<span class="nc" id="L240">                    this._esCopion[res[i]] = true; // O(1)</span>
                }
<span class="nc" id="L242">                return res; // O(1)</span>
    
            } else { // O(1)
<span class="fc" id="L245">                int E = estudiantes.length; // O(1)</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                if (E &lt;= 1) { // O(1)</span>
<span class="nc" id="L247">                    this._esCopion = new boolean[E]; // O(1)</span>
<span class="nc" id="L248">                    return new int[0]; // O(1)</span>
                }
    
<span class="fc" id="L251">                int maxRespuesta = 0; // O(1)</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                for (int i = 0; i &lt; E; i++) { // Bucle externo O(E)</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                    for (int j = 0; j &lt; ExamenCanonico.length; j++) { // Bucle interno O(R)</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                        if (estudiantes[i].respuestas[j] &gt; maxRespuesta) { // O(1)</span>
<span class="fc" id="L255">                            maxRespuesta = estudiantes[i].respuestas[j]; // O(1)</span>
                        }
                    }
                }
    
<span class="fc" id="L260">                int umbral = (E - 1 + 3) / 4; // O(1)</span>
<span class="fc" id="L261">                int R = ExamenCanonico.length; // O(1)</span>

<span class="fc" id="L263">                boolean[][] esRespuestaSospechosa = new boolean[E][R]; // O(E*R)</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">                for (int j = 0; j &lt; R; j++) { // Bucle externo O(R)</span>
<span class="fc" id="L265">                    int[] counts = new int[maxRespuesta + 1]; // O(1) (dominio acotado)</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                    for (int i = 0; i &lt; E; i++) { // Bucle interno O(E)</span>
<span class="fc" id="L267">                        int respuesta = estudiantes[i].respuestas[j]; // O(1)</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                        if (respuesta != -1) { // O(1)</span>
<span class="fc" id="L269">                            counts[respuesta]++; // O(1)</span>
                        }
                    }
<span class="fc bfc" id="L272" title="All 2 branches covered.">                    for (int i = 0; i &lt; E; i++) { // Bucle interno O(E)</span>
<span class="fc" id="L273">                        int respuesta = estudiantes[i].respuestas[j]; // O(1)</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                        if (respuesta != -1) { // O(1)</span>
<span class="fc" id="L275">                            int count = counts[respuesta]; // O(1)</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                            if ((count - 1) &gt;= umbral) { // O(1)</span>
<span class="fc" id="L277">                                esRespuestaSospechosa[i][j] = true; // O(1)</span>
                            }
                        }
                    }
                }

<span class="fc" id="L283">                boolean[] esCopion = new boolean[E]; // O(E)</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                for (int i = 0; i &lt; E; i++) { // Bucle externo O(E)</span>
<span class="fc" id="L285">                    boolean todasSospechosas = true; // O(1)</span>
<span class="fc" id="L286">                    int respuestasContestadas = 0; // O(1)</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                    for (int j = 0; j &lt; R; j++) { // Bucle interno O(R)</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                        if (estudiantes[i].respuestas[j] == -1) continue; // O(1)</span>
<span class="fc" id="L289">                        respuestasContestadas++; // O(1)</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                        if (!esRespuestaSospechosa[i][j]) { // O(1)</span>
<span class="fc" id="L291">                            todasSospechosas = false; // O(1)</span>
<span class="fc" id="L292">                            break; // O(1)</span>
                        }
                    }
<span class="fc bfc" id="L295" title="All 4 branches covered.">                    if (respuestasContestadas &gt; 0 &amp;&amp; todasSospechosas) { // O(1)</span>
<span class="fc" id="L296">                        esCopion[i] = true; // O(1)</span>
                    }
                }
                
<span class="fc" id="L300">                this._esCopion = esCopion; // O(1)</span>
    
<span class="fc" id="L302">                int countSospechosos = 0; // O(1)</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                for (int i = 0; i &lt; E; i++) { // Bucle O(E)</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                    if (esCopion[i]) { // O(1)</span>
<span class="fc" id="L305">                        countSospechosos++; // O(1)</span>
                    }
                }
    
<span class="fc" id="L309">                int[] res = new int[countSospechosos]; // O(S)</span>
<span class="fc" id="L310">                int index = 0; // O(1)</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                for (int i = 0; i &lt; E; i++) { // Bucle O(E)</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                    if (esCopion[i]) { // O(1)</span>
<span class="fc" id="L313">                        res[index++] = i; // O(1)</span>
                    }
                }
<span class="fc" id="L316">                return res; // O(1)</span>
            }
        }

    // Complejidad: O(E*log E)
    public NotaFinal[] corregir() { // O(E*log E)
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (this._esCopion == null) { // O(1)</span>
<span class="nc" id="L323">            return null; // O(1)</span>
        }

<span class="fc" id="L326">        int cantidadValidas = 0; // O(1)</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">            if (estudiantes[i].entregado &amp;&amp; !_esCopion[i]) { // O(1)</span>
<span class="fc" id="L329">                cantidadValidas++; // O(1)</span>
            }
        }

<span class="fc" id="L333">        NotaFinal[] notas_array = new NotaFinal[cantidadValidas]; // O(V)</span>
<span class="fc" id="L334">        int idx = 0; // O(1)</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (int i = 0; i &lt; estudiantes.length; i++) { // Bucle O(E)</span>
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">            if (estudiantes[i].entregado &amp;&amp; !_esCopion[i]) { // O(1)</span>
<span class="fc" id="L337">                notas_array[idx] = new NotaFinal(estudiantes[i].puntaje, estudiantes[i].id); // O(1)</span>
<span class="fc" id="L338">                idx++; // O(1)</span>
            }
        }

<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (notas_array.length &gt; 0) { // O(1)</span>
<span class="fc" id="L343">            mergeSort(notas_array, 0, notas_array.length - 1); // O(V log V)</span>
        }
<span class="fc" id="L345">        return notas_array; // O(1)</span>
    }

    private void mergeSort(NotaFinal[] arr, int inicio, int fin) { // O(N log N) donde N = fin - inicio
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (inicio &lt; fin) { // O(1)</span>
<span class="fc" id="L350">            int medio = inicio + (fin - inicio) / 2; // O(1)</span>
            // Cada llamada recursiva tiene un costo de O(N/2 * log(N/2))
<span class="fc" id="L352">            mergeSort(arr, inicio, medio);</span>
<span class="fc" id="L353">            mergeSort(arr, medio + 1, fin);</span>
            // La combinación de los resultados toma O(N)
<span class="fc" id="L355">            merge(arr, inicio, medio, fin);</span>
        }
<span class="fc" id="L357">    }</span>

    private void merge(NotaFinal[] arr, int inicio, int medio, int fin) { // O(N) donde N = fin - inicio
<span class="fc" id="L360">        int n1 = medio - inicio + 1; // O(1)</span>
<span class="fc" id="L361">        int n2 = fin - medio; // O(1)</span>
<span class="fc" id="L362">        NotaFinal[] izq = new NotaFinal[n1]; // O(n1)</span>
<span class="fc" id="L363">        NotaFinal[] der = new NotaFinal[n2]; // O(n2)</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; i++) izq[i] = arr[inicio + i]; // Bucle O(n1)</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (int j = 0; j &lt; n2; j++) der[j] = arr[medio + 1 + j]; // Bucle O(n2)</span>

<span class="fc" id="L367">        int i = 0, j = 0, k = inicio; // O(1)</span>
<span class="fc bfc" id="L368" title="All 4 branches covered.">        while (i &lt; n1 &amp;&amp; j &lt; n2) { // Bucle O(n1+n2) = O(N)</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (compararNotaFinal(izq[i], der[j]) &lt;= 0) { // O(1)</span>
<span class="fc" id="L370">                arr[k++] = izq[i++]; // O(1)</span>
            } else {
<span class="fc" id="L372">                arr[k++] = der[j++]; // O(1)</span>
            }
        }
<span class="fc bfc" id="L375" title="All 2 branches covered.">        while (i &lt; n1) arr[k++] = izq[i++]; // Bucle O(n1)</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        while (j &lt; n2) arr[k++] = der[j++]; // Bucle O(n2)</span>
<span class="fc" id="L377">    }</span>

    private int compararNotaFinal(NotaFinal a, NotaFinal b) { // O(1)
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (a._nota != b._nota) { // O(1)</span>
<span class="fc" id="L381">            return Double.compare(b._nota, a._nota); // O(1)  // descendiente por nota</span>
        }
<span class="fc" id="L383">        return Integer.compare(b._id, a._id); // O(1)  // descendiente por ID</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>